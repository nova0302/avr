* atmel studio 7 install
  - [[https://www.microchip.com/mplab/avr-support/atmel-studio-7][atmel studio 7]]
    
* USB ISP
  - tools -> add target
#+CAPTION: USB ISP SETTING
#+NAME:   fig:SED-HR4049
[[./images/addTarget.jpg]]

* AVR
  
** fuse bit Settgin
   - tools -> device programming -> 
   - [[https://m.blog.naver.com/PostView.nhn?blogId=nkkh159&logNo=220801733605&proxyReferer=https://www.google.com/][fuse bit setting link]]
#+CAPTION: Fuse Bit Setting for 8 F_CPU internal oscillator
#+NAME:   fig:SED-HR4049
[[./images/fuseSetting.jpg]]
     
** avr studio keyboard shortcut
   
*** Ctl + Alt + F5 -> compile && download
    
*** F7 -> project build
    
*** auto indentation

**** Ctl-k, Ctl-d -> Format Document

**** Ctl-k, Ctl-f -> Format Selection
     
* Day 1
  
** GPIO

#+BEGIN_SRC C
  /*
   * Author : Sanglae Kim
   */ 
  #include <stdio.h> //for printf
  #include <stdint.h> // for uint~~
  #include <assert.h>
  #include <stdbool.h>

  #define F_CPU 8000000UL
  #include <avr/io.h>
  #include <util/delay.h>

  #define BAUD 9600
  #define MYUBRR F_CPU/16/BAUD-1

  void USART_init(unsigned int ubrr) {
      UBRRH = (unsigned char)(ubrr >> 8);
      UBRRL = (unsigned char)ubrr;
      UCSRB = 1 << RXEN  | 1 << TXEN;
      UCSRC = 1 << URSEL | 1 << USBS | 3 << UCSZ0;
  }

  int USART_transmit( unsigned char data, FILE *stream ) {
      while(!(UCSRA & (1 << UDRE)));
      UDR = data;
      return 0;
  }

  int main(void)
  {
      fdevopen(USART_transmit, NULL);
      DDRB = (1 << DDB0);
      USART_init(MYUBRR);
      uint8_t i=0;
	
      /* Replace with your application code */
      while (1) 
      {
	  if(PINB & (1 << PINB1)){
	      printf("%d: Hello Wrold\r\n", i++);	
	      _delay_ms(1000);
	  }else{
	      _delay_ms(100);
	  }
	  PORTB ^= 1;
      }
  }

#+END_SRC

* Day 2
** Timer1 Interrupt
   
#+BEGIN_SRC C
//https://github.com/monoclecat/avr-millis-function
  #include <stdio.h> //for printf
  #include <stdint.h> // for uint~~
  #include <assert.h>
  #include <stdbool.h>

  #define F_CPU 8000000UL
  #include <avr/io.h>
  #include <util/delay.h>
  #include <util/atomic.h>
  #include <avr/interrupt.h>

  unsigned long millis ();
  void init_millis(unsigned long f_cpu);

  int main(void)
  {
      unsigned long tNow, tLast=0;
      uint8_t btnLast, btnNow;
      DDRB = (1 << DDB0);
	
      init_millis(8000000UL); //the frequency Atmega16a is running at
      sei();

      while (1)
      {		
	  tNow = millis();
	  if(tNow - tLast > 10){
	      btnNow = (PINB & (1 << PINB1)) ? 1 : 0;
	      if(!btnNow && btnLast)
		  PORTB ^= 1;	
	      btnLast = btnNow;
	      tLast = tNow;	 
	  }
	  /*
	    _delay_ms(100);
	    PORTB ^= 1;
	  ,*/
      }
  }

  volatile unsigned long timer1_millis;
  //NOTE: A unsigned long holds values from 0 to 4,294,967,295 (2^32 - 1). It will roll over to 0 after reaching its maximum value.

  ISR(TIMER1_COMPA_vect)
  {
      timer1_millis++;
  }

  void init_millis(unsigned long f_cpu)
  {
      unsigned long ctc_match_overflow;
	
      ctc_match_overflow = ((f_cpu / 1000) / 8); //when timer1 is this value, 1ms has passed
	
      // (Set timer to clear when matching ctc_match_overflow) | (Set clock divisor to 8)
      TCCR1B |= (1 << WGM12) | (1 << CS11);
	
      // high byte first, then low byte
      OCR1AH = (ctc_match_overflow >> 8);
      OCR1AL = ctc_match_overflow;
	
      // Enable the compare match interrupt
      TIMSK |= (1 << OCIE1A);
	
      //REMEMBER TO ENABLE GLOBAL INTERRUPTS AFTER THIS WITH sei(); !!!
  }

  unsigned long millis ()
  {
      unsigned long millis_return;
	
      // Ensure this cannot be disrupted
      ATOMIC_BLOCK(ATOMIC_FORCEON) {
	  millis_return = timer1_millis;
      }
      return millis_return;
  }

#+END_SRC

** Timer0 Interrupt
   
#+BEGIN_SRC C

  /*
   ,* timer0Interrupt.c
   ,*
   ,* Created: 2020-08-11 오전 4:31:18
   ,* Author : Sanglae Kim
   ,*/ 


  #include <stdio.h> //for printf
  #include <stdint.h> // for uint~~
  #include <assert.h>
  #include <stdbool.h>

  #define F_CPU 8000000UL
  #include <avr/io.h>
  #include <util/delay.h>
  #include <util/atomic.h>
  #include <avr/interrupt.h>

  unsigned long millis ();
  void init_millis(unsigned long f_cpu);


  int main(void)
  {
      unsigned long tNow, tLast=0;
      uint8_t btnLast, btnNow;
      DDRB = (1 << DDB0);
	
      init_millis(8000000UL); //the frequency Atmega16a is running at
      sei();

      while (1)
      {		
	  tNow = millis();
	  if(tNow - tLast > 10){
	      btnNow = (PINB & (1 << PINB1)) ? 1 : 0;
	      if(!btnNow && btnLast)
		  PORTB ^= 1;	
	      btnLast = btnNow;
	      tLast = tNow;	 
	  }
	  /*
	    _delay_ms(100);
	    PORTB ^= 1;
	  ,*/
      }
  }

  volatile unsigned long timer1_millis;
  //NOTE: A unsigned long holds values from 0 to 4,294,967,295 (2^32 - 1). It will roll over to 0 after reaching its maximum value.

  ISR(TIMER0_COMP_vect)
  {
      PORTB ^= 1;	
  }

  void init_millis(unsigned long f_cpu)
  {
      unsigned long ctc_match_overflow;
	
      ctc_match_overflow = ((f_cpu / 1000) / 8); //when timer1 is this value, 1ms has passed
	
      // (Set timer to clear when matching ctc_match_overflow) | (Set clock divisor to 8)
      TCCR0 |= (1 << CS02) | (1 << CS00); // devide by 1024 -> 8M/1K = 8K
	
      // high byte first, then low byte
      OCR0 = 255;
	
      // Enable the compare match interrupt
      TIMSK |= (1 << OCIE0);
	
      //REMEMBER TO ENABLE GLOBAL INTERRUPTS AFTER THIS WITH sei(); !!!
  }

  unsigned long millis ()
  {
      unsigned long millis_return;
	
      // Ensure this cannot be disrupted
      ATOMIC_BLOCK(ATOMIC_FORCEON) {
	  millis_return = timer1_millis;
      }
      return millis_return;
  }



#+END_SRC
